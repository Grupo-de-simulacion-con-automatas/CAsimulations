# -*- coding: utf-8 -*-
"""Funciones del modelo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Sj4uPgxzRQTWw142tmkxpXJs98g0drbZ
"""

import numpy as np
import matplotlib.pyplot as plt
import cv2
import string
import pandas as pd
import glob
import random 
from skimage.color import rgb2gray
import seaborn as sns
import scipy.integrate as spi
import math

def spline3(A):     #spline cubico para la lista de coordenadas A 
    n = len(A) 
    a = []; h = []; x = []; y = []*(n-1); C = [0]*n
    alpha = []
    l = [1]
    B = [0] 
    g = [0]; gn = 0
    spline = []
    for i in range(n):
        a.append(A[i][1])
    for i in range(n-1):
        xh = A[i+1][0]-A[i][0]
        h.append(xh)
    for i in range(1, n-1):
        xa = (3/h[i])*(a[i+1]-a[i])-(3/h[i-1])*(a[i]-a[i-1])
        alpha.append(xa)
    for i in range(1, n-1):
        xl = 2*(A[i+1][0]-A[i-1][0])-h[i-1]*B[i-1]
        l.append(xl)
        xb = h[i]/l[i]
        B.append(xb)
        xg = (alpha[i-1]-h[i-1]*g[i-1])/l[i]
        g.append(xg)
    l.append(1)
    g.append(0)
    for i in range(n-1):
        j = (n-1)-(i+1)
        xC = g[j]-B[j]*C[j+1]
        C[j] = xC
        xy = ((a[j+1]-a[j])/h[j])-(h[j]/3)*(C[j+1]+2*C[j])
        y.append(xy)
        xx = (C[j+1]-C[j])/(3*h[j])
        x.append(xx)
    for i in range(n-1):
        j=(n-1)-(i+1)
        S3 = [a[i],y[j],C[i],x[j]]
        spline.append(S3)
    SC=np.array(spline)
    return SC

def one_function_graph(A,texto): #Grafica del spline cubico para la lista de coordenadas A
    cond=[]            
    funcion=[]
    SP=spline3(A)
    cond=[]
    funcion=[]
    x=[]
    y=[]
    for i in range(len(spline3(A))):
        xa=np.linspace(A[i,0],A[i+1,0]-0.0001,11)
        x=np.concatenate((x,xa))
        ya=SP[i,0]+SP[i,1]*(xa-A[i,0])+SP[i,2]*(xa-A[i,0])**2+SP[i,3]*(xa-A[i,0])**3
        y=np.concatenate((y,ya))
  
    texto=str(texto)
    plt.plot(x, y, c='blue')
    plt.title(texto)
    plt.xlabel('Tiempo')
    plt.show()

def one_state_graph(A,texto): #Grafica del spline cubico para la lista de coordenadas A
    cond=[]            
    funcion=[]
    SP=spline3(A)
    cond=[]
    funcion=[]
    x=[]
    y=[]; l=[]
    for i in range(len(spline3(A))):
        xa=np.linspace(A[i,0],A[i+1,0]-0.0001,11)
        x=np.concatenate((x,xa))
        ya=SP[i,0]+SP[i,1]*(xa-A[i,0])+SP[i,2]*(xa-A[i,0])**2+SP[i,3]*(xa-A[i,0])**3
        y=np.concatenate((y,ya))
    
    texto=str(texto)
    plt.plot(x, x**0, 'k--')
    plt.plot(x, y, c='blue')
    plt.title(texto)
    plt.xlabel('Tiempo')
    plt.ylim(0,1.05)
    plt.show()

def two_states_graph(A,B,texto1, texto2, titulo): #Grafica del spline cubico para las listas de coordenadas A y B
    cond=[]             
    funcion=[]
    SA=spline3(A)
    SB=spline3(B)
    cond=[]
    funcion=[]
    x=[]
    y=[]
    z=[]
    for i in range(len(spline3(A))):
        xa=np.linspace(A[i,0],A[i+1,0]-0.0001,11)
        x=np.concatenate((x,xa))
        ya=SA[i,0]+SA[i,1]*(xa-A[i,0])+SA[i,2]*(xa-A[i,0])**2+SA[i,3]*(xa-A[i,0])**3
        y=np.concatenate((y,ya))
        za=SB[i,0]+SB[i,1]*(xa-B[i,0])+SB[i,2]*(xa-B[i,0])**2+SB[i,3]*(xa-B[i,0])**3
        z=np.concatenate((z,za))
  
    texto1=str(texto1); texto2=str(texto2);  titulo=str(titulo)
    plt.plot(x, x**0, 'k--')
    plt.plot(x, y, c='y', label=texto1)
    plt.plot(x, z, c='r', label=texto2)
    plt.legend(loc=0)
    plt.title(titulo)
    plt.xlabel('Tiempo')
    plt.ylim(0,1.05)
    plt.show()

def three_states_graph(A,B,C,texto1,texto2,texto3,titulo): #Grafica del spline cubico para las listas de coordenadas A,B y C
    cond=[]             
    funcion=[]
    SA=spline3(A)
    SB=spline3(B)
    SC=spline3(C)
    cond=[]
    funcion=[]
    x=[]
    y=[]
    z=[]
    w=[]
    for i in range(len(spline3(A))):
        xa=np.linspace(A[i,0],A[i+1,0]-0.0001,11)
        x=np.concatenate((x,xa))
        ya=SA[i,0]+SA[i,1]*(xa-A[i,0])+SA[i,2]*(xa-A[i,0])**2+SA[i,3]*(xa-A[i,0])**3
        y=np.concatenate((y,ya))
        za=SB[i,0]+SB[i,1]*(xa-B[i,0])+SB[i,2]*(xa-B[i,0])**2+SB[i,3]*(xa-B[i,0])**3
        z=np.concatenate((z,za))
        wa=SC[i,0]+SC[i,1]*(xa-C[i,0])+SC[i,2]*(xa-C[i,0])**2+SC[i,3]*(xa-C[i,0])**3
        w=np.concatenate((w,wa))
  
    texto1=str(texto1); texto2=str(texto2); texto3=str(texto3);  titulo=str(titulo)
    plt.plot(x, y, c='y', label=texto1)
    plt.plot(x, z, c='g', label=texto2)
    plt.plot(x, w, c='r', label=texto3)
    plt.plot(x, x**0, 'k--')
    plt.legend(loc=0)
    plt.title(titulo)
    plt.xlabel('Tiempo')
    plt.ylim(0,1.05)
    plt.show()

def distribution_graph(A,B,C,D,E,F,G,H,I,J):  #Grafica de variación presente en la condición inicial
    cond=[]             
    funcion=[]
    SA=spline3(A); SB=spline3(B); SC=spline3(C); SD=spline3(D); SE=spline3(E)
    SF=spline3(F); SG=spline3(G); SH=spline3(H); SI=spline3(I); SJ=spline3(J)
    x=[]; y=[]; z=[]; w=[]; t=[]; a=[]
    b=[]; c=[]; d=[]; e=[]; f=[]
    for i in range(len(spline3(A))):
        xa=np.linspace(A[i,0],A[i+1,0]-0.0001,11)
        x=np.concatenate((x,xa))
        ya=SA[i,0]+SA[i,1]*(xa-A[i,0])+SA[i,2]*(xa-A[i,0])**2+SA[i,3]*(xa-A[i,0])**3
        y=np.concatenate((y,ya))
        za=SB[i,0]+SB[i,1]*(xa-B[i,0])+SB[i,2]*(xa-B[i,0])**2+SB[i,3]*(xa-B[i,0])**3
        z=np.concatenate((z,za))
        wa=SC[i,0]+SC[i,1]*(xa-C[i,0])+SC[i,2]*(xa-C[i,0])**2+SC[i,3]*(xa-C[i,0])**3
        w=np.concatenate((w,wa))
        ta=SD[i,0]+SD[i,1]*(xa-D[i,0])+SD[i,2]*(xa-D[i,0])**2+SD[i,3]*(xa-D[i,0])**3
        t=np.concatenate((t,ta))
        aa=SE[i,0]+SE[i,1]*(xa-E[i,0])+SE[i,2]*(xa-E[i,0])**2+SE[i,3]*(xa-E[i,0])**3
        a=np.concatenate((a,aa))
        ba=SF[i,0]+SF[i,1]*(xa-F[i,0])+SF[i,2]*(xa-F[i,0])**2+SF[i,3]*(xa-F[i,0])**3
        b=np.concatenate((b,ba))
        ca=SG[i,0]+SG[i,1]*(xa-G[i,0])+SG[i,2]*(xa-G[i,0])**2+SG[i,3]*(xa-G[i,0])**3
        c=np.concatenate((c,ca))
        da=SH[i,0]+SH[i,1]*(xa-H[i,0])+SH[i,2]*(xa-H[i,0])**2+SH[i,3]*(xa-H[i,0])**3
        d=np.concatenate((d,da))
        ea=SI[i,0]+SI[i,1]*(xa-I[i,0])+SI[i,2]*(xa-I[i,0])**2+SI[i,3]*(xa-I[i,0])**3
        e=np.concatenate((e,ea))
        fa=SJ[i,0]+SJ[i,1]*(xa-J[i,0])+SJ[i,2]*(xa-J[i,0])**2+SJ[i,3]*(xa-J[i,0])**3
        f=np.concatenate((f,fa))
  
    plt.plot(x, y, c='g', label="noroeste")
    plt.plot(x, z, c='gold', label="norte")
    plt.plot(x, w, c='peru', label="noreste")
    plt.plot(x, t, c='c', label="oeste")
    plt.plot(x, a, c='magenta', label="central")
    plt.plot(x, b, c='darkorange', label="este")
    plt.plot(x, c, c='royalblue', label="suroeste")
    plt.plot(x, d, c='mediumorchid', label="sur")
    plt.plot(x, e, c='r', label="sureste")
    plt.plot(x, f, c='lime', label="aleatorio")
    plt.plot(x, x**0, 'k--')
    plt.legend(loc=0)
    plt.title('Condición inicial')
    plt.xlabel('Tiempo')
    plt.ylim(0,1.05)
    plt.show()

def scales_graph(A,B,C,D,E): #Gráfica de cambios de escalas
    cond=[]             
    funcion=[]
    SA=spline3(A); SB=spline3(B); SC=spline3(C); SD=spline3(D); SE=spline3(E)
    x=[]; y=[]; z=[]; w=[]; t=[]; l=[]
    for i in range(len(spline3(A))):
        xa=np.linspace(A[i,0],A[i+1,0]-0.0001,11)
        x=np.concatenate((x,xa))
        ya=SA[i,0]+SA[i,1]*(xa-A[i,0])+SA[i,2]*(xa-A[i,0])**2+SA[i,3]*(xa-A[i,0])**3
        y=np.concatenate((y,ya))
        za=SB[i,0]+SB[i,1]*(xa-B[i,0])+SB[i,2]*(xa-B[i,0])**2+SB[i,3]*(xa-B[i,0])**3
        z=np.concatenate((z,za))
        wa=SC[i,0]+SC[i,1]*(xa-C[i,0])+SC[i,2]*(xa-C[i,0])**2+SC[i,3]*(xa-C[i,0])**3
        w=np.concatenate((w,wa))
        ta=SD[i,0]+SD[i,1]*(xa-D[i,0])+SD[i,2]*(xa-D[i,0])**2+SD[i,3]*(xa-D[i,0])**3
        t=np.concatenate((t,ta))
        la=SE[i,0]+SE[i,1]*(xa-E[i,0])+SE[i,2]*(xa-E[i,0])**2+SE[i,3]*(xa-E[i,0])**3
        l=np.concatenate((l,la))
  
    plt.plot(x, y, c='purple', label="escala 1")
    plt.plot(x, z, c='steelblue', label="escala 2")
    plt.plot(x, w, c='darkorange', label="escala 3")
    plt.plot(x, t, c='firebrick', label="escala 4")
    plt.plot(x, l, c='seagreen', label="escala 5")
    plt.plot(x, x**0, 'k--')
    plt.legend(loc=0)
    plt.title('Cambio de escalas')
    plt.xlabel('Tiempo')
    plt.ylim(0,1.05)
    plt.show()

def systems_graph(A,B,C,D,E,F,G): #Gráfica de cambios de escalas
    cond=[]             
    funcion=[]
    SA=spline3(A); SB=spline3(B); SC=spline3(C); SD=spline3(D); SE=spline3(E); SF=spline3(F); SG=spline3(G)
    x=[]; y=[]; z=[]; w=[]; t=[]; l=[]; o=[]; p=[]
    for i in range(len(spline3(A))):
        xa=np.linspace(A[i,0],A[i+1,0]-0.0001,11)
        x=np.concatenate((x,xa))
        ya=SA[i,0]+SA[i,1]*(xa-A[i,0])+SA[i,2]*(xa-A[i,0])**2+SA[i,3]*(xa-A[i,0])**3
        y=np.concatenate((y,ya))
        za=SB[i,0]+SB[i,1]*(xa-B[i,0])+SB[i,2]*(xa-B[i,0])**2+SB[i,3]*(xa-B[i,0])**3
        z=np.concatenate((z,za))
        wa=SC[i,0]+SC[i,1]*(xa-C[i,0])+SC[i,2]*(xa-C[i,0])**2+SC[i,3]*(xa-C[i,0])**3
        w=np.concatenate((w,wa))
        ta=SD[i,0]+SD[i,1]*(xa-D[i,0])+SD[i,2]*(xa-D[i,0])**2+SD[i,3]*(xa-D[i,0])**3
        t=np.concatenate((t,ta))
        la=SE[i,0]+SE[i,1]*(xa-E[i,0])+SE[i,2]*(xa-E[i,0])**2+SE[i,3]*(xa-E[i,0])**3
        l=np.concatenate((l,la))
        oa=SF[i,0]+SF[i,1]*(xa-F[i,0])+SF[i,2]*(xa-F[i,0])**2+SF[i,3]*(xa-F[i,0])**3
        o=np.concatenate((o,oa))
        pa=SG[i,0]+SG[i,1]*(xa-G[i,0])+SG[i,2]*(xa-G[i,0])**2+SG[i,3]*(xa-G[i,0])**3
        p=np.concatenate((p,pa))
        
    plt.plot(x, y, c='purple', label="Linea")
    plt.plot(x, z, c='steelblue', label="Cuadrado")
    plt.plot(x, w, c='darkorange', label="Rectángulo")
    plt.plot(x, t, c='firebrick', label="Rombo")
    plt.plot(x, l, c='seagreen', label="Triángulo")
    plt.plot(x, l, c='cyan', label="Caso #1")
    plt.plot(x, l, c='orangered', label="Caso #2")
    plt.plot(x, x**0, 'k--')
    plt.legend(loc=0)
    plt.title('Comparación entre sistemas')
    plt.xlabel('Tiempo')
    plt.ylim(0,1.05)
    plt.show()

def scales_difference_graph(A,B,C,D): #Gráfica de cambios de escalas
    cond=[]             
    funcion=[]
    SA=spline3(A); SB=spline3(B); SC=spline3(C); SD=spline3(D)
    x=[]; y=[]; z=[]; w=[]; t=[]; l=[]
    for i in range(len(spline3(A))):
        xa=np.linspace(A[i,0],A[i+1,0]-0.0001,11)
        x=np.concatenate((x,xa))
        ya=SA[i,0]+SA[i,1]*(xa-A[i,0])+SA[i,2]*(xa-A[i,0])**2+SA[i,3]*(xa-A[i,0])**3
        y=np.concatenate((y,ya))
        za=SB[i,0]+SB[i,1]*(xa-B[i,0])+SB[i,2]*(xa-B[i,0])**2+SB[i,3]*(xa-B[i,0])**3
        z=np.concatenate((z,za))
        wa=SC[i,0]+SC[i,1]*(xa-C[i,0])+SC[i,2]*(xa-C[i,0])**2+SC[i,3]*(xa-C[i,0])**3
        w=np.concatenate((w,wa))
        ta=SD[i,0]+SD[i,1]*(xa-D[i,0])+SD[i,2]*(xa-D[i,0])**2+SD[i,3]*(xa-D[i,0])**3
        t=np.concatenate((t,ta))
  
    plt.plot(x, y, c='purple', label="|E5-E1|")
    plt.plot(x, z, c='steelblue', label="|E5-E2|")
    plt.plot(x, w, c='darkorange', label="|E5-E3|")
    plt.plot(x, t, c='firebrick', label="|E5-E4|")
    plt.legend(loc=0)
    plt.title('Diferencias')
    plt.xlabel('Tiempo')
    plt.show()

def array_generator(K,i,j):  #Se genera la veindad para la célula en la posición i,j en el arreglo regular (Ar)
    A = np.zeros((3,3))      #La vecindad debe tener 8 agentes y una célula central
    A[0][0] = K[i-1][j-1]    #Vecino en la possición i-1,j-1
    A[0][1] = K[i-1][j]      #Vecino en la possición i-1,j
    A[0][2] = K[i-1][j+1]    #Vecino en la possición i-1,j+1
    A[1][0] = K[i][j-1]      #Vecino en la possición i,j-1
    A[1][1] = K[i][j]        #Célula central
    A[1][2] = K[i][j+1]      #Vecino en la possición i,j+1
    A[2][0] = K[i+1][j-1]    #Vecino en la possición i+1,j-1
    A[2][1] = K[i+1][j]      #Vecino en la possición i+1,j
    A[2][2] = K[i+1][j+1]    #Vecino en la possición i+1,j+1
    return A                 #Vecindad del agente en la posición i,j

def vector_S(A):               #Definición del conjunto de posiciones del estado S en el sistema A
    n,m=A.shape                #Consideramos la dimensión del sistema A
    S=[]                       #S guardará las posiciones de los individuos susceptibles
    for i in range(n):         #para i en n filas
        for j in range(m):     #para j en m columnas
            if A[i][j]==0:     #Verifique si el individuo en la posición i,j es susceptible
                S.append([i,j])#Si es verdadero añanda la posición del individuo a la lista S
    return S                   #Retorne la lista de posiciones de los individuos susceptibles

def vector_I(A):               #Definición del conjunto de posiciones del estado I en el sistema A
    n,m=A.shape                #Consideramos la dimensión del sistema A
    I=[]                       #I guardará las posiciones de los individuos infectados
    for i in range(n):         #para i en n filas
        for j in range(m):     #para j en m columnas
            if A[i][j]==1:     #Verifique si el individuo en la posición i,j esta infectado
                I.append([i,j])#Si es verdadero añanda la posición del individuo a la lista I
    return I                   #Retorne la lista de posiciones de los individuos infectados

def sumaS(V):                 #Cantidad de individuos susceptibles en la vecindad V
    sumaS=0                   #Antes de realizar el conteo se toma un contador igual a cero
    for i in range(3):        #Tres filas en la vecindad de Moore
        for j in range(3):    #Tres columnas en la vecindad de Moore
            if V[i][j]==0:    #Para cada individuo se verifica si está identificado con el estado S
                sumaS=sumaS+1 #Si es verdadero, aumente en uno el contador de susceptibles
    if V[1][1]==0:            #La célula central no se considera en el conteo  
        sumaS=sumaS-1         #Si la célula central es susceptible se elimina de la suma
    return sumaS              #cantidad de suscptibles en la vecindad V

def sumaI(V):                 #Cantidad de individuos infectados en la vecindad V
    sumaI=0                   #Antes de realizar el conteo se toma un contador igual a cero
    for i in range(3):        #Tres filas en la vecindad de Moore
        for j in range(3):    #Tres columnas en la vecindad de Moore
            if V[i][j]==1:    #Para cada individuo se verifica si está identificado con el estado I
                sumaI=sumaI+1 #Si es verdadero, aumente en uno el contador de infectados
    if V[1][1]==1:            #La célula central no se considera en el conteo  
        sumaI=sumaI-1         #Si la célula central esta infectada se elimina de la suma
    return sumaI              #cantidad de infectados en la vecindad V

def sumaR(V):                 #Cantidad de individuos recuperados en la vecindad V
    sumaR=0                   #Antes de realizar el conteo se toma un contador igual a cero
    for i in range(3):        #Tres filas en la vecindad de Moore
        for j in range(3):    #Tres columnas en la vecindad de Moore
            if V[i][j]==2:    #Para cada individuo se verifica si está identificado con el estado R
                sumaR=sumaR+1 #Si es verdadero, aumente en uno el contador de recuperados
    if V[1][1]==2:            #La célula central no se considera en el conteo  
        sumaR=sumaR-1         #Si la célula central esta recuperada se elimina de la suma
    return sumaR              #cantidad de recuperados en la vecindad V

def sumaV(V):                 #Cantidad de espacios vacios en la vecindad V
    sumaV=0                   #Antes de realizar el conteo se toma un contador igual a cero
    for i in range(3):        #Tres filas en la vecindad de Moore
        for j in range(3):    #Tres columnas en la vecindad de Moore
            if V[i][j]==-1:   #Para cada espacio se verifica si está identificado con el estado V
                sumaV=sumaV+1 #Si es verdadero, aumente en uno el contador de recuperados
    if V[1][1]==-1:           #La célula central no se considera en el conteo  
        sumaV=sumaV-1         #Si la célula central no está se elimina de la suma
    return sumaV              #cantidad de espacios vacios en la vecindad V

def count_S(A):             #Cantidad de individuos que poseen el estado S en el arreglo A
    n,m=A.shape             #Dim(A)=nm
    suma=0                  #Antes de realizar el conteo se toma un contador igual a cero
    for i in range(n):      #n filas del arreglo A
        for j in range(m):  #m columnas del arreglo A
            if A[i][j]==0:  #Para cada espacio se verifica si está identificado con el estado S
                suma=suma+1 #Si es verdadero, aumente en uno el contador de susceptibles
    return int(suma)        #cantidad de individuos susceptibles en el arreglo A

def count_I(A):             #Cantidad de individuos que poseen el estado I en el arreglo A
    n,m=A.shape             #Dim(A)=nm
    suma=0                  #Antes de realizar el conteo se toma un contador igual a cero
    for i in range(n):      #n filas del arreglo A
        for j in range(m):  #m columnas del arreglo A
            if A[i][j]==1:  #Para cada espacio se verifica si está identificado con el estado I
                suma=suma+1 #Si es verdadero, aumente en uno el contador de infectados
    return int(suma)        #cantidad de individuos infectados en el arreglo A

def count_R(A):             #Cantidad de individuos que poseen el estado R en el arreglo A
    n,m=A.shape             #Dim(A)=nm
    suma=0                  #Antes de realizar el conteo se toma un contador igual a cero
    for i in range(n):      #n filas del arreglo A
        for j in range(m):  #m columnas del arreglo A
            if A[i][j]==2:  #Para cada espacio se verifica si está identificado con el estado R
                suma=suma+1 #Si es verdadero, aumente en uno el contador de recuperados
    return int(suma)        #cantidad de individuos recuperados en el arreglo A

def count_D(A):             #Cantidad de individuos que poseen el estado D en el arreglo A
    n,m=A.shape             #Dim(A)=nm
    suma=0                  #Antes de realizar el conteo se toma un contador igual a cero
    for i in range(n):      #n filas del arreglo A
        for j in range(m):  #m columnas del arreglo A
            if A[i][j]==3:  #Para cada espacio se verifica si está identificado con el estado D
                suma=suma+1 #Si es verdadero, aumente en uno el contador de recuperados
    return int(suma)        #cantidad de individuos muertos en el arreglo A

def num_individuals(A): #Función contadora de individuos que interactuan en el sistema A 
    n = count_S(A)      #Cantidad de individuos que poseen el estado S
    m = count_I(A)      #Cantidad de individuos que poseen el estado I
    o = count_R(A)      #Cantidad de individuos que poseen el estado R
    d = count_D(A)      #Cantidad de individuos que poseen el estado D
    ci = n + m + o + d  #Total de individuos que interactuan en el sistema
    return ci           #Retorna ci

def count_s(A):                          #Función de población normalizada para el estado S          
    return count_S(A)/num_individuals(A) #Promedio de susceptibles con respecto a células que interactuan

def count_i(A):                          #Función de población normalizada para el estado I
    return count_I(A)/num_individuals(A) #Promedio de infectados con respecto a células que interactuan

def count_r(A):                          #Función de población normalizada para el estado R
    return count_R(A)/num_individuals(A) #Promedio de recuperados con respecto a células que interactuan

def count_d(A):                          #Función de población normalizada para el estado D
    return count_D(A)/num_individuals(A) #Promedio de muertos con respecto a células que interactuan

def base_rule(alpha,beta,V):                    #Regla base de interacción local      
    I = sumaI(V); S = sumaS(V); Va = sumaV(V)   #Se realiza un conteo de infectados, susceptibles y espacios vacios en la vecindad V            
    B = np.zeros((3,3))                         #Para evitar problemas de apuntadores se realiza la transformación sobre una copia de V
    r = random.randint(0,100)                   #El valor aleatorio rho
    for i in range(3):                          #Copia de las tres filas de la vecindad V
        for j in range(3):                      #Copia de las tres columnas de la vecindad V
            B[i][j] = V[i][j]                   #Copia de los indiviuos en la vecindad V
    if V[1][1] != -1:                                           #Se consideran unicamente los espacios no vacios ya que la tranformación de un espacio vacio es vacio
        if I > 0:                                               #Si no hay infectados en la vecindad, no hay propagacióón de la enfermedad en la vecindad
            if I <= S and r >= (I/(8 - Va))*(beta/alpha) * 100: #Condición para transición al estado S 
                B[1][1] = 0     
            else:                                               #Condición para transición al estado I
                B[1][1] = 1
        else:
            B[1][1] = V[1][1]
    else:                                       #Si la célula es vacia se mantiene vacia
        B[1][1] = -1
    return B[1][1]                              #Al ser una regla totalíística, se retorna el valor central

def evolution_sis(alpha,beta,U):  #Regla base de evolucion en U de parametros alpha y beta
    n,m=U.shape                   #dim(U)=nm
    B=np.zeros((n+2,m+2))         #B será un arreglo nulo sobre el cual se sobreescribiran los datos de U
    C=np.zeros((n,m))             #C será el arreglo que guardará los datos luego de aplicar la regla base de evolución 
    I=count_I(U)                  #Se aplicará la regla siempre y cuando existan individuos infectados
    for i in range(n):                              
        for j in range(m):
            B[i+1][j+1]=U[i][j]   #Se sobreescriben los datos de U sobre B
    for i in range(n):
        for j in range(m):
            if I > 0:                                                      #Si hay individuos infectados en el sistema
                C[i][j]=base_rule(alpha,beta,array_generator(B,i+1,j+1))   #Aplique la regla base de evolución local a U y guarde los valores en C 
            else:                                                          #Si no hay individuos infectados
                C[i][j] = U[i][j]                                          #La regla base de evolución actua como la función identica sobre el sistema
    return C                      #Retorne la evolución del sistema

def evolution_SIS(alpha,beta,tf,A):         #Definición del conjunto de evoluciones 
    L = [A]                                 #El primer elemento del conjunto es la configuracióón inicial
    i = 0                                   #Se define el contador de composiciones
    while i <= tf:                                 #Se realizarán composiciones hasta el tiempo tf 
        i = i + 1                                  #El contador crece en una unidad
        L.append(evolution_sis(alpha,beta,L[i-1])) #Se añade la composición i del arreglo en la posición i-1 
    return L

def SIS_model(alpha,beta,tf,A):                   #Modelo SIS
    S = []; I = []                                #S e I guardan la cantidad de individuos pertenecientes a los estados S e I por cada iteración 
    CI = np.zeros((tf,2)); CS = np.zeros((tf,2))  #CS y CI nos permitiran graficar los datos de S e I
    B = evolution_SIS(alpha,beta,tf,A)            #Calculamos la evolución inicial del sistema A hasta el tiempo tf
    for j in range(tf):                           #Para cada iteración defina
        M = B[j]                                  #M será la evolución en el instante t=i
        S.append(count_s(M))                      #Añadimos el promedio de susceptibles en M a S 
        I.append(count_i(M))                      #Añadimos el promedio de infectados en M a I                           
    for i in range(tf):                           #Para cada instante i hasta tf defina
        CS[i][0] = i; CS[i][1] = S[i]             #CS[i]=(i,S[i]) -> (tiempo i, cantidad de susceptibles en el tiempo i)
        CI[i][0] = i; CI[i][1] = I[i]             #CI[i]=(i,I[i]) -> (tiempo i, cantidad de infectados en el tiempo i)
    return [CS,CI,S,I,B]                          #Lista con las parejas ordenadas CS, CI, cantidad de individuos susceptibles, infectados y las evoluciones del sistema

def num_I(a,b):               #Porcentaje de infectados en el espacio (a de cada b están infectados)
    A=np.zeros((1,b))         #Generamos una b-tupla, la vemos como un arreglo para facilitar la manipulación 
    L=[]                      #L sera la lista cuyos elelementos son a de b infectados
    for j in range(a):          #a individuos recibirán la cualidad de infectados 
        i=random.randint(1,b-1) #La posición de los individuos infectados será aleatoria en el arreglo A
        A[0][i]=1               #El individuo en la posición aleatoria 0,i adquiere el estado de infección 
    for m in range(1,b):        #Se añadirán los elementos del arreglo A en la lista L
        L.append(int(A[0][m]))  
    return L                  #Retorne la lista porcentaje de indiviuos infectados

def initial_condition(I0,A):   #Condición inicial aplicada al sistema A
    L=vector_S(A)              #Defina L como el vector de posiciones del estado S en el sistema A
    n,m=A.shape                #dim(A)=nm
    k=math.ceil(len(L)*I0)     #El I0% de los individuos susceptibles adquieren la enfermedad, se toma la función techo para redondear a un entero esta cantidad
    R=num_I(k,len(L)+1)        #R es la lista de posiciones de los idividuos que se infectaron y de los que se mantuvieron sanos al aplicar la condicion inicial
    C=np.zeros((n,m))          #Se define C para evitar problemas de apuntadores
    for i in range(n):            #Para i en las n filas de A 
        for j in range(m):        #Para j en las m columnas de A
            C[i][j]=A[i][j]       #C será una copia de A, esto permite que la información de A no se modifique
    for i in range(len(R)):       #Para i en un rango de 0 a la longitud de la lista R
        C[L[i][0]][L[i][1]]=R[i]  #Los vectores en las posiciones descritas en la lista R adquieren el estado de infección
    return C                   #Se retorna el arreglo con la condición inicial

def graph_sis_S(alpha,beta,tf,A):          #Grafica que describe la evolución de la población susceptible en el modelo SIS
    SIS=SIS_model(alpha,beta,tf,A)         #Se aplica el modelo al sistema A, con tasas de recuperación e infección hasta un tiempo tf
    one_state_graph(SIS[0],"Susceptibles") #Graficamos los datos mediante un spline cubico de la lista S generada por la función sis

def graph_sis_I(alpha,beta,tf,A):          #Grafica que describe la evolución de la población infectados en el modelo SIS
    SIS=SIS_model(alpha,beta,tf,A)         #Se aplica el modelo al sistema A, con tasas de recuperación e infección hasta un tiempo tf
    one_state_graph(SIS[1], "Infectados")  #Graficamos los datos mediante un spline cubico de la lista I generada por la función sis

def graph_sis(alpha,beta,tf,A):         #Grafica del modelo SIS
    SIS=SIS_model(alpha,beta,tf,A)      #Se aplica el modelo al sistema A, con tasas de recuperación e infección hasta un tiempo tf
    two_states_graph(SIS[0],SIS[1],"Susceptibles", "Infectados", "Modelo SIS")  #Graficamos los datos mediante un spline cubico de las listas S e I generadas por la función sis

def interaction_SI(alpha,beta,A):     #Regla de interacción del estado S
    n,m=A.shape                       #dim(A)=nm
    B=np.zeros((n+2,m+2))             #Se aplica la condición para las células en la frontera
    C=np.zeros((n,m))                 #Se define la matriz C para evitar problemas de apuntadores
    for i in range(n):
        for j in range(m):
            B[i+1][j+1]=A[i][j]           
    for i in range(n):
        for j in range(m): 
            if A[i][j]==0:                                                #Si el estado de la célula es susceptible aplique la regla base de interaccion local
                C[i][j]=base_rule(alpha,beta,array_generator(B,i+1,j+1))
            elif A[i][j]==2:                                              #Para el estado R funciona como la identidad
                C[i][j]=2
            elif A[i][j]==-1:                                             #La regla no se aplica en espacios vacios
                C[i][j]=-1
            elif A[i,j]==3: #opcional
                C[i,j]=3
            else:                                                         #La regla actua como la identica en el estado I
                C[i][j]=1
    return C                                                              #Retorna la evolución del sistema A bajo la regla de S

def num_R(a,b):               #Porcentaje de recuperados en el espacio (a de cada b están curados)
    A=np.ones((1,b))          #Generamos una b-tupla, la vemos como un arreglo para facilitar la manipulación 
    L=[]                      #L sera la lista cuyos elelementos son a de b recuperados
    for j in range(a):          #a individuos recibirán la cualidad de recuperados
        i=random.randint(1,b-1) #La posición de los individuos recuperados será aleatoria en el arreglo A
        A[0][i]=2               #El individuo en la posición aleatoria 0,i adquiere el estado de recuperado
    for m in range(1,b):        #Se añadirán los elementos del arreglo A en la lista L
        L.append(int(A[0][m]))  
    return L                  #Retorne la lista porcentaje de indiviuos recuperados

def interaction_IR(alpha,A):      #Regla de interacción del estado I
    L=vector_I(A)                 #Generamos el conjunto de posiciones de infectados del sistema A
    n,m=A.shape                   #dim(A)=nm
    k=math.ceil(len(L)*alpha)     #alpha% de los infectados se curará
    R=num_R(k,len(L)+1)           #Generamos la lista en la cual de manera explicita tenemos alpha recuperados de una poblacióón infectada
    C=np.zeros((n,m))             #Se creará una copia de A para evitar problemas de apuntadores
    for i in range(n):
        for j in range(m):
            C[i][j]=A[i][j]
    for i in range(len(R)):       #Los individuos que se recuperarón se envian a la posición que tenian en el estado I  
        C[L[i][0]][L[i][1]]=R[i]
    return C                      #Retorna la evolución del sistema A bajo la regla de I

def evolution_sir(alpha,beta,A):    #Regla de comportamiento SIR
    B=interaction_IR(alpha,A)      #Primero se evalua cuales individuos se curarán el el siguiente tic
    C=interaction_SI(alpha,beta,B)  #Los que no se curaróón siguen infectando la población susceptible
    return C                        #Sistema al aplicar la regla de comportamiento SIR

def evolution_SIR(alpha,beta,tf,A):         #Lista de evoluciones al aplicar SIR hasta un tiempo tf
    L=[A]                                   #El primer elemento de la lista es la configuración inicial
    i=0                                     #Aplique SIR hasta el tiempo tf
    while i<=tf:
        i=i+1
        L.append(evolution_sir(alpha,beta,L[i-1]))   #Se aplica SIR al arreglo en la posición anterior del contador
    return L                                         #Lista de evoluciones en un sistema bajo la aplicación SIR

def SIR_model(alpha,beta,tf,A):       #Modelo SIR
    S=[]; I=[]; R=[]                  #Listas que guardarán la cantidad de individuos por estado normalizada
    CI=np.zeros((tf,2))               #Arreglo que permitirá graficar la población infectada
    CS=np.zeros((tf,2))               #Arreglo que permitirá graficar la población susceptible
    CR=np.zeros((tf,2))               #Arreglo que permitirá graficar la población recuperada
    B=evolution_SIR(alpha,beta,tf,A)  #Lista de evoluciones del sistema A hasta el tiemp tf
    for j in range(tf):               #Para cada elemento en la lista 
        M=B[j]                        #M es la evolución en el tiempo j
        S.append(count_s(M))          #Población susceptible normalizada 
        I.append(count_i(M))          #Población infectada normalizada
        R.append(count_r(M))          #Población recuperada normalizada 
    for i in range(tf):               #Se generan las listas de coordenadas que permitirán graficar la evolución
        CS[i][0]=i; CS[i][1]=S[i]     #Coordenadas de cantidad de susceptibles
        CI[i][0]=i; CI[i][1]=I[i]     #Coordenadas de cantidad de infectados
        CR[i][0]=i; CR[i][1]=R[i]     #Coordenadas de cantidad de recuperados
    return [CS,CR,CI,S,I,R,B]         #Lista con las coordenadas de los tres estados, cantidades normalizadas y las evoluciones

def graph_sir_S(alpha,beta,tf,A):            #Gráfica de la población susceptible
    SIR=SIR_model(alpha,beta,tf,A)           #Se aplica el modelo bajo las condiciones de la función
    one_state_graph(SIR[0], "Susceptibles")  #Gráfica de la población susceptible

def graph_sir_I(alpha,beta,tf,A):          #Gráfica de la población infectada
    SIR=SIR_model(alpha,beta,tf,A)         #Se aplica el modelo bajo las condiciones de la función      
    one_state_graph(SIR[2], "Infectados")  #Gráfica de la población infectada

def graph_sir_R(alpha,beta,tf,A):          #Gráfica de la población recuperada      
    SIR=SIR_model(alpha,beta,tf,A)         #Se aplica el modelo bajo las condiciones de la función 
    one_state_graph(SIR[1], "Recuperados") #Gráfica de la población recuperada

def graph_sir(alpha,beta,tf,A):      #Gráfica del modelo SIR
    SIR=SIR_model(alpha,beta,tf,A)   #Se aplica el modelo bajo las condiciones de la función 
    three_states_graph(SIR[0],SIR[1],SIR[2],"Susceptibles","recuperados","infectados","Modelo SIR")

def color(A):                 #Transformación que permite visualizar el sistema en escala nipy_spectral
    n,m=A.shape               #dim(A)=nm
    C=np.zeros((n,m))         #Se realizará una copia de A para evitar problemas de apuntadores
    for i in range(n):          
        for j in range(m):
            C[i][j]=A[i][j]
    for i in range(n):
        for j in range(m):
            if C[i][j]==0:    #A los individuos susceptibles se les asigna el color amarillo
                C[i][j]=190   
            if C[i][j]==1:    #A los individuos infectados se les asigna el color rojo
                C[i][j]=240
            if C[i][j]==2:    #A los individuos recuperados se les asigna el color verde
                C[i][j]=115
            if C[i][j]==-1:   #A los espacios vacios se les asigna el color negro
                C[i][j]=0
            if C[i][j]==3:
                C[i][j]=256
    D=np.zeros((n+2,m+2)) 
    for i in range(n):                              
        for j in range(m):
            D[i+1][j+1]=C[i][j]
    D[0][0]=0; D[n+1][m+1]=256  #Polos de color para poder ajustar la escala de manera adecuada
    return D

def heatmap_sis(alpha,beta,tf,A):                          #Mapa de calor de la enfermedad hasta el tiempo tf
    a,b=A.shape
    B=SIS_model(alpha,beta,tf,A)[4]
    C=[]
    for i in range(len(B)):
        D=np.zeros((a,b)); F=np.zeros((a,b))
        for j in range(a):
            for k in range(b):
                if B[i][j][k]==1:
                    D[j][k]=1
        C.append(D)
    suma1=1/tf*np.sum(C,axis=0)
    sns.heatmap(suma1, center=0, cmap='viridis',  fmt='.3f')

def heatmap_sir_I(alpha,beta,tf,A):
    a,b=A.shape
    B=SIR_model(alpha,beta,tf,A)[6]
    C=[]
    for i in range(len(B)):
        D=np.zeros((a,b)); F=np.zeros((a,b))
        for j in range(a):
            for k in range(b):
                if B[i][j][k]==1:
                    D[j][k]=1
        C.append(D)
    suma1=1/tf*np.sum(C,axis=0)
    sns.heatmap(suma1, center=0, cmap='viridis',  fmt='.3f')

def heatmap_sir_R(alpha,beta,tf,A):
    a,b=A.shape
    B=SIR_model(alpha,beta,tf,A)[6]
    C=[]
    for i in range(len(B)):
        D=np.zeros((a,b)); F=np.zeros((a,b))
        for j in range(a):
            for k in range(b):
                if B[i][j][k]==2:
                    D[j][k]=1
        C.append(D)
    suma1=1/tf*np.sum(C,axis=0)
    sns.heatmap(suma1, center=0, cmap='viridis',  fmt='.3f')

def northwest(n,m,I0):               #Bloque noroeste
    D=np.zeros((n,m))                #Creamos el arreglo rectángular sobre el cual se realizará el analisis
    D=initial_condition(I0*0.005,D)  #Un porcentaje muy pequeño de los individuos infectados no se encontrará en el bloque noroeste 
    a=int(n/3); b=int(m/3)           #Se divide la zona rectángular en 9 bloques
    A=np.zeros((a,b))                #Bloque sobre el cual estarán ubicados la mayoria de los enfermos
    D1=initial_condition(0.995-I0,A) 
    for i in range(a):
        for j in range(b):
            D[i][j]=D1[i][j]         #Se reemplazan los valores del bloque noroeste por el bloque de infectados
    return D

def north(n,m,I0):                    #Bloque norte
    D=np.zeros((n,m))                 #Creamos el arreglo rectángular sobre el cual se realizará el analisis
    D=initial_condition(I0*.005,D)    #Un porcentaje muy pequeño de los individuos infectados no se encontrará en el bloque norte
    a=int(n/3); b=int(m/3)            #Se divide la zona rectángular en 9 bloques
    A=np.zeros((a,b))                 #Bloque sobre el cual estarán ubicados la mayoria de los enfermos
    D1=initial_condition(0.995-I0,A)
    for i in range(a):
        for j in range(b,2*b):
            D[i][j]=D1[i][j-b]        #Se reemplazan los valores del bloque norte por el bloque de infectados
    return D

def northeast(n,m,I0):                #Bloque noreste
    D=np.zeros((n,m))                 #Creamos el arreglo rectángular sobre el cual se realizará el analisis
    D=initial_condition(I0*.005,D)    #Un porcentaje muy pequeño de los individuos infectados no se encontrará en el bloque noreste
    a=int(n/3); b=int(m/3)            #Se divide la zona rectángular en 9 bloques
    A=np.zeros((a,b))                 #Bloque sobre el cual estarán ubicados la mayoria de los enfermos
    D1=initial_condition(.995-I0,A)
    for i in range(a):
        for j in range(2*b,3*b):
            D[i][j]=D1[i][j-2*b]      #Se reemplazan los valores del bloque noreste por el bloque de infectados
    return D

def west(n,m,I0):                    #Bloque oeste
    D=np.zeros((n,m))                #Creamos el arreglo rectángular sobre el cual se realizará el analisis
    D=initial_condition(I0*.005,D)   #Un porcentaje muy pequeño de los individuos infectados no se encontrará en el bloque oeste
    a=int(n/3); b=int(m/3)           #Se divide la zona rectángular en 9 bloques
    A=np.zeros((a,b))                #Bloque sobre el cual estarán ubicados la mayoria de los enfermos
    D1=initial_condition(.995-I0,A)
    for i in range(a,a*2):
        for j in range(b):
            D[i][j]=D1[i-a][j]        #Se reemplazan los valores del bloque oeste por el bloque de infectados
    return D

def center(n,m,I0):                  #Bloque central
    D=np.zeros((n,m))                #Creamos el arreglo rectángular sobre el cual se realizará el analisis
    D=initial_condition(I0*.005,D)   #Un porcentaje muy pequeño de los individuos infectados no se encontrará en el bloque central
    a=int(n/3); b=int(m/3)           #Se divide la zona rectángular en 9 bloques
    A=np.zeros((a,b))                #Bloque sobre el cual estarán ubicados la mayoria de los enfermos
    D1=initial_condition(.995-I0,A)
    for i in range(a,a*2):
        for j in range(b,2*b):
            D[i][j]=D1[i-a][j-b]      #Se reemplazan los valores del bloque central por el bloque de infectados
    return D

def east(n,m,I0):                    #Bloque este
    D=np.zeros((n,m))                #Creamos el arreglo rectángular sobre el cual se realizará el analisis
    D=initial_condition(I0*.005,D)   #Un porcentaje muy pequeño de los individuos infectados no se encontrará en el bloque este
    a=int(n/3); b=int(m/3)           #Se divide la zona rectángular en 9 bloques
    A=np.zeros((a,b))                #Bloque sobre el cual estarán ubicados la mayoria de los enfermos
    D1=initial_condition(.995-I0,A)
    for i in range(a,a*2):
        for j in range(2*b,3*b):
            D[i][j]=D1[i-a][j-2*b]   #Se reemplazan los valores del bloque este por el bloque de infectados
    return D

def southwest(n,m,I0):                #Bloque suroeste
    D=np.zeros((n,m))                 #Creamos el arreglo rectángular sobre el cual se realizará el analisis
    D=initial_condition(I0*.005,D)    #Un porcentaje muy pequeño de los individuos infectados no se encontrará en el bloque suroeste
    a=int(n/3); b=int(m/3)            #Se divide la zona rectángular en 9 bloques
    A=np.zeros((a,b))                 #Bloque sobre el cual estarán ubicados la mayoria de los enfermos
    D1=initial_condition(.995-I0,A)
    for i in range(2*a,3*a):
        for j in range(b):
            D[i][j]=D1[i-2*a][j]      #Se reemplazan los valores del bloque suroeste por el bloque de infectados
    return D

def south(n,m,I0):                  #Bloque sur
    D=np.zeros((n,m))               #Creamos el arreglo rectángular sobre el cual se realizará el analisis
    D=initial_condition(I0*.005,D)  #Un porcentaje muy pequeño de los individuos infectados no se encontrará en el bloque sur
    a=int(n/3); b=int(m/3)          #Se divide la zona rectángular en 9 bloques
    A=np.zeros((a,b))               #Bloque sobre el cual estarán ubicados la mayoria de los enfermos
    D1=initial_condition(.995-I0,A)
    for i in range(2*a,3*a):
        for j in range(b,2*b):
            D[i][j]=D1[i-2*a][j-b]    #Se reemplazan los valores del bloque sur por el bloque de infectados
    return D

def southeast(n,m,I0):                #Bloque sureste
    D=np.zeros((n,m))                 #Creamos el arreglo rectángular sobre el cual se realizará el analisis
    D=initial_condition(I0*.005,D)    #Un porcentaje muy pequeño de los individuos infectados no se encontrará en el bloque sureste
    a=int(n/3); b=int(m/3)            #Se divide la zona rectángular en 9 bloques
    A=np.zeros((a,b))                 #Bloque sobre el cual estarán ubicados la mayoria de los enfermos
    D1=initial_condition(.995-I0,A)
    for i in range(2*a,3*a):
        for j in range(2*b,3*b):
            D[i][j]=D1[i-2*a][j-2*b]  #Se reemplazan los valores del bloque sureste por el bloque de infectados
    return D

def aleatorio(n,m,I0):        #Distribución aleatoria en el espacio
    D=np.zeros((n,m))         #Creamos el arreglo rectángular sobre el cual se realizará el analisis
    D=initial_condition(I0,D) #Se aplica la condición inicial
    return D

def medium_curves_sis(alpha,beta,tf,csim,I0,A):     #Promedio de csim simulaciones para el modelo SIS
    S=[]; I=[]                                      #S e I guardarán el promedio de las cantidades normalizadas por estados respectivos
    cs=[]; ci=[]                                    #cs y ci serán las listas que permiten promediar la cantidad de individuos para csim simulaciones
    CI=np.zeros((tf,2)); CS=np.zeros((tf,2))        #Hay tf coordenadas
    for i in range(csim):                                          #Para csim simulaciones 
        promsis=SIS_model(alpha,beta,tf,initial_condition(I0,A))   #Aplique un condición inicial de distribución uniforme de infectados 
        cs.append(promsis[2]); ci.append(promsis[3])               #Las listas S e I generadas por cada iteración son enviadas a las listas cs y ci
    for i in range(tf):                                            #Se promedian las cantidades
        k=0; l=0
        for j in range(csim):
            k=k+cs[j][i]/csim; l=l+ci[j][i]/csim 
        S.append(k); I.append(l)                    #Las cantidades promedio son enviadas a las listas S e I
    for i in range(tf):                             #Se crean las listas de coordenadas
        CS[i][0]=i; CS[i][1]=S[i]
        CI[i][0]=i; CI[i][1]=I[i]
    return [CS,CI,S,I]                              #Datos promedio del modelo SIS para csim simulaciones

def graph_medium_curves_sis(alpha,beta,tf,csim,I0,A):   #Grafica del promedio de simulaciones para el modelo SIS
    SIS=medium_curves_sis(alpha,beta,tf,csim,I0,A)
    two_states_graph(SIS[0],SIS[1],"susceptibles","infectados","Curva promedio - Modelo SIS")

def medium_curves_sir(alpha,beta,tf,csim,I0,A):                   #Promedio de csim simulaciones para el modelo SIR
    S=[]; I=[]; R=[]                                              #S,I y R guardarán el promedio de las cantidades normalizadas por estados respectivos
    cs=[]; ci=[]; cr=[]                                           #cs,ci y cr serán las listas que permiten promediar la cantidad de individuos para csim simulaciones
    CI=np.zeros((tf,2)); CS=np.zeros((tf,2)); CR=np.zeros((tf,2)) #Hay tf coordenadas
    for i in range(csim):                                                   #Para csim simulaciones
        promsir=SIR_model(alpha,beta,tf,initial_condition(I0,A))            #Aplique un condición inicial de distribución uniforme de infectados 
        cs.append(promsir[3]); ci.append(promsir[4]); cr.append(promsir[5]) #Las listas S, I y R generadas por cada iteración son enviadas a las listas cs, ci y cr
    for i in range(tf):                                                     #Se promedian las cantidades
        k=0; l=0; p=0
        for j in range(csim):
            k=k+cs[j][i]; l=l+ci[j][i]; p=p+cr[j][i]
        k=k/csim; l=l/csim; p=p/csim 
        S.append(k); I.append(l); R.append(p)                      #Las cantidades promedio son enviadas a las listas S, I y R
    for i in range(tf):                                            #Se crean las listas de coordenadas
        CS[i][0]=i; CS[i][1]=S[i]
        CI[i][0]=i; CI[i][1]=I[i]
        CR[i][0]=i; CR[i][1]=R[i]
    return [CS,CR,CI,S,I,R]                                        #Datos promedio del modelo SIR para csim simulaciones

def graph_medium_curves_sir(alpha,beta,tf,csim,I0,A):        #Grafica del promedio de simulaciones para el modelo SIR
    SIR=medium_curves_sir(alpha,beta,tf,csim,I0,A)
    three_states_graph(SIR[0],SIR[1],SIR[2],"Susceptibles","Recuperados","Infectados","Curva promedio - Modelo SIR")

def boundary(L,M):            #La lista L posee las coordenadas que definen las posiciones nulas en el sistema M 
    n,m=M.shape
    K=np.ones((n,m))
    for i in range(n):
        for j in range(m):
            K[i][j]=M[i][j]
    for i in range(len(L)):   #Para cada coordenada
        K[L[i][0],L[i][1]]=0  #Cambie la posición respectiva de la matriz M por cero
    return K                  #Retorne el sistema M

def domain_definition(n,m,a,b,M):   #Ubica una matriz nula de tamaño nxm en la posición a,b de M
    L=[]                            #Lista de coordenadas que se anularán 
    for i in range(n):      
        for j in range(m):
            L.append((a+i,b+j))     #Ingrese a la lista L las coordenadas de las posiciones de la submatriz nula
    return boundary(L,M)            #Reemplace las nxm posiciones de M por ceros en las posiciones a,b

def rombo(a,b,c,d,B):           #Rombo de diagonal mayor igual al doble de diagonal menor
    L=[B]
    i=0
    while c>1:
        a=a+2; b=b-4; c=c-1; d=d+2; i=i+1
        L.append(domain_definition(a,b,c,d,L[i-1]))
    return L[i]

def triangulo(n,m,a,b,M):
    L=[M]
    i=0
    while m>=1:
        i=i+1
        L.append(domain_definition(n,m,a,b,L[i-1]))
        m=m-2; a=a-1; b=b+1
    return L[i]

def scale_differences(L1,L2):      #Calcula las diferencias entre dos escalas L1 y L2
    L=np.zeros((len(L1),2))
    for i in range(len(L1)):
        L[i][0]=i; L[i][1]=abs(L1[i]-L2[i])
    return L

def three_states_graph_2(A,B,C,titulo): #Gráfica el modelo SIS tomando además la población muerta
    cond=[]             
    funcion=[]
    SA=spline3(A); SB=spline3(B); SC=spline3(C)
    x=[]; y=[]; z=[]; w=[]
    for i in range(len(spline3(A))):
        xa=np.linspace(A[i,0],A[i+1,0]-0.0001,11)
        x=np.concatenate((x,xa))
        ya=SA[i,0]+SA[i,1]*(xa-A[i,0])+SA[i,2]*(xa-A[i,0])**2+SA[i,3]*(xa-A[i,0])**3
        y=np.concatenate((y,ya))
        za=SB[i,0]+SB[i,1]*(xa-B[i,0])+SB[i,2]*(xa-B[i,0])**2+SB[i,3]*(xa-B[i,0])**3
        z=np.concatenate((z,za))
        wa=SC[i,0]+SC[i,1]*(xa-C[i,0])+SC[i,2]*(xa-C[i,0])**2+SC[i,3]*(xa-C[i,0])**3
        w=np.concatenate((w,wa))
  
    plt.plot(x, y, c='y', label="Susceptibles")
    plt.plot(x, z, c='r', label="Infectados")
    plt.plot(x, w, 'b--', label="Muertos")
    plt.plot(x, x**0, 'k--')
    plt.legend(loc=0)
    plt.title(str(titulo))
    plt.xlabel('Tiempo')
    plt.ylim(0,1.05)
    plt.show()

def four_states_graph(A,B,C,D,titulo):      #Gráfica el modelo SIR tomando además la población muerta
    cond=[]             
    funcion=[]
    SA=spline3(A); SB=spline3(B); SC=spline3(C); SD=spline3(D)
    x=[]; y=[]; z=[]; w=[]; t=[]; l=[]
    for i in range(len(spline3(A))):
        xa=np.linspace(A[i,0],A[i+1,0]-0.0001,11)
        x=np.concatenate((x,xa))
        ya=SA[i,0]+SA[i,1]*(xa-A[i,0])+SA[i,2]*(xa-A[i,0])**2+SA[i,3]*(xa-A[i,0])**3
        y=np.concatenate((y,ya))
        za=SB[i,0]+SB[i,1]*(xa-B[i,0])+SB[i,2]*(xa-B[i,0])**2+SB[i,3]*(xa-B[i,0])**3
        z=np.concatenate((z,za))
        wa=SC[i,0]+SC[i,1]*(xa-C[i,0])+SC[i,2]*(xa-C[i,0])**2+SC[i,3]*(xa-C[i,0])**3
        w=np.concatenate((w,wa))
        ta=SD[i,0]+SD[i,1]*(xa-D[i,0])+SD[i,2]*(xa-D[i,0])**2+SD[i,3]*(xa-D[i,0])**3
        t=np.concatenate((t,ta))
  
    plt.plot(x, y, c='y', label="Susceptibles")
    plt.plot(x, z, c='r', label="Infectados")
    plt.plot(x, w, c='g', label="Recuperados")
    plt.plot(x, t, 'b--', label="Muertos")
    plt.plot(x, x**0, 'k--')
    plt.legend(loc=0)
    plt.title(str(titulo))
    plt.xlabel('Tiempo')
    plt.ylim(0,1.05)
    plt.show()

def ages(ranges, A):   #Genera la matriz de edades para A basada en los datos de rangos
    n,m=A.shape          #dimensión de A
    Ci=num_individuals(A)   
    L=[]
    for i in range(len(ranges)):   #Cantidad de rangos de edad
        L.append([0]*math.ceil(ranges[i][2]*Ci))   #Lista nula tomando el porcentaje de cada rango de edad en la cantidad de individuos
    for i in range(len(L)):   #Cantidad de divisiones del espacio por grupos de edad
        for j in range(len(L[i])):   #Cantidad de individuos por cada grupo de edad
            L[i][j]=random.randint(ranges[i][0],ranges[i][1])   #A cada individuo se le asigna una edad en el rango definido por las dos primeras componentes de rangos
    Ed=L[0]
    for i in range(1,len(L)):
        Ed=Ed+L[i]   #Se unen todas las listas con las edades
    E=-np.ones((n,m))  #Se crea el arreglo sobre el cual se distribuiran las edades de manera aleatoria
    for i in range(n):
        for j in range(m):
            if A[i,j]!=-1 and A[i,j]!=3:   #Si el píxel no es un espacio vacío o un agente muerto se le asigna una edad
                p=random.choice(Ed)
                E[i,j]=p
            elif A[i,j]==3:
                E[i,j]=0
    return E

def age_group(a,b,A):   #Genera las posiciones de los individuos que tienen entre a y b años en A
    n,m=A.shape
    E=[]
    for i in range(n):
        for j in range(m):
            if a<A[i][j] and A[i][j]<b:
                E.append([i,j])
    return E

def evolution_ages(br,mr,E,time_unit,year):   #Evolución por año de los agentes
    n,m=E.shape
    E1=np.zeros((n,m))
    for i in range(n):
        for j in range(m):
            if E[i][j]!=0 and E[i][j]!=-1 and time_unit%year==0:   #Si se cumple la condición, los individuos "cumplirán un año"
                E1[i][j]=E[i][j]+1
            elif E[i,j]==0:   #Los individuos muertos tienen una probabilidad br de reaparecer
                p=random.randint(0,100)
                if p<br:       
                    E1[i][j]=1
            elif E[i,j]==-1:
                E1[i,j]=-1
            else:
                E1[i,j]=E[i,j]
    N=[]; a=[]
    for i in range(len(mr)):   #Se separan los grupos de edades para aplicar las tasas de mortalidad de mr
        N.append(age_group(mr[i][0],mr[i][1],E))
        a.append(math.ceil(len(N[i])*mr[i][2])-1)
    v=[]
    for i in range(len(a)):
        for j in range(a[i]):
            b=random.randint(0,len(N[i])-1)
            v.append(N[i][b])
    for i in range(len(v)):
        E1[v[i][0]][v[i][1]]=0
    return E1

def evolution_sis_bm(alpha,beta,br,mr,A,E,time_unit,year):   #Regla de evolución del modelo SIS con natalidad y mortalidad
    Ed=evolution_ages(br,mr,E,time_unit,year)   #Evolución de las edades
    B=evolution_sis(alpha,beta,A)   #Se aplica el modelo SIS usual
    n,m=A.shape
    C=np.zeros((n,m))
    for i in range(n):
        for j in range(m):
            if Ed[i,j]==0:   #Si en la evolución de edades, la edad de un agente es 0 el agente se representará como muerto
                C[i,j]=3
            elif Ed[i,j]==1:   #Si en la evolución de edades, la edad de un agente es 1 el agente es susceptible
                C[i,j]=0
            else:
                C[i,j]=B[i,j]
    return [C,Ed]

def evolution_sir_bm(alpha,beta,br,mr,A,E,time_unit,year):   #Regla de evolución del modelo SIR con natalidad y mortalidad
    Ed=evolution_ages(br,mr,E,time_unit,year)   #Evolución de las edades
    B=evolution_sir(alpha,beta,A)   #Se aplica el modelo SIR usual
    n,m=A.shape
    C=np.zeros((n,m))
    for i in range(n):
        for j in range(m):
            if Ed[i,j]==0:   #Si en la evolución de edades, la edad de un agente es 0 el agente se representará como muerto
                C[i,j]=3
            elif Ed[i,j]==1:   #Si en la evolución de edades, la edad de un agente es 1 el agente es susceptible
                C[i,j]=0
            else:
                C[i,j]=B[i,j]
    return [C,Ed]

def evolution_SIS_bm(alpha,beta,tf,br,mr,A,E,year):   #Aplica el modelo SIS con natalidad y mortalidad tf veces sobre el sistema A
    L=[A]
    Ed=[E]
    i = 0                                 
    while i <= tf:                        
        i = i + 1     
        A=evolution_sis_bm(alpha,beta,br,mr,L[i-1],Ed[i-1],i,year)
        L.append(A[0])
        Ed.append(A[1])
    return L

def evolution_SIR_bm(alpha,beta,tf,br,mr,A,E,year):   #Aplica el modelo SIR con natalidad y mortalidad tf veces sobre el sistema A
    L=[A]
    Ed=[E]
    i = 0                                 
    while i <= tf:                        
        i = i + 1     
        A=evolution_sir_bm(alpha,beta,br,mr,L[i-1],Ed[i-1],i,year)
        L.append(A[0])
        Ed.append(A[1])
    return L

def SIS_bm_model(alpha,beta,tf,br,mr,A,E,year):   #Modelo SIS con natalidad y mortalidad                      
    S = []; I = []; D = []                               
    CI = np.zeros((tf,2)); CS = np.zeros((tf,2)); CD = np.zeros((tf,2))   
    B = evolution_SIS_bm(alpha,beta,tf,br,mr,A,E,year)                  
    for j in range(tf):                           
        M = B[j]                                    
        S.append(count_s(M))                       
        I.append(count_i(M))  
        D.append(count_d(M))
    for i in range(tf):                           
        CS[i][0] = i; CS[i][1] = S[i]               
        CI[i][0] = i; CI[i][1] = I[i] 
        CD[i][0] = i; CD[i][1] = D[i]  
    return [CS,CI,CD,S,I,D,B]

def SIR_bm_model(alpha,beta,tf,br,mr,A,E,year):   #Modelo SIR con natalidad y mortalidad                     
    S = []; I = []; R = []; D = []                               
    CI = np.zeros((tf,2)); CS = np.zeros((tf,2)); CR = np.zeros((tf,2)); CD = np.zeros((tf,2))   
    B = evolution_SIR_bm(alpha,beta,tf,br,mr,A,E,year)                  
    for j in range(tf):                           
        M = B[j]                                    
        S.append(count_s(M))                       
        I.append(count_i(M)) 
        R.append(count_r(M))  
        D.append(count_d(M))
    for i in range(tf):                           
        CS[i][0] = i; CS[i][1] = S[i]               
        CI[i][0] = i; CI[i][1] = I[i] 
        CR[i][0] = i; CR[i][1] = R[i]
        CD[i][0] = i; CD[i][1] = D[i]  
    return [CS,CR,CI,CD,S,I,R,D,B]

def graph_sis_bm(alpha,beta,tf,br,mr,A,E,year):   #Gráfica del modelo SIS con natalidad y mortalidad
    SIS=SIS_bm_model(alpha,beta,tf,br,mr,A,E,year)
    three_states_graph_2(SIS[0],SIS[1],SIS[2], "Modelo SIR con tasa de natalidad/mortalidad")

def graph_sir_bm(alpha,beta,tf,br,mr,A,E,year):   #Gráfica del modelo SIR con natalidad y mortalidad  
    SIR=SIR_bm_model(alpha,beta,tf,br,mr,A,E,year)
    four_states_graph(SIR[0],SIR[2],SIR[1],SIR[3], "Modelo SIR con tasa de natalidad/mortalidad")

def dead_by_disease(ranges_dead,A,E):   #Aplica probabilidades de muerte por enfermedad a grupos de edad sobre el sistema A 
    n,m=A.shape
    B=np.zeros((n,m))
    C=np.zeros((n,m))
    vecN=[]
    a=[]
    v=[]
    for i in range(n):      #Se guarda la información para eitar problemas de apuntadores
        for j in range(m):
            B[i,j]=E[i,j]
            C[i,j]=A[i,j]
    for i in range(len(ranges_dead)):
        N1=age_group(ranges_dead[i][0],ranges_dead[i][1],B)
        N2=[]
        for j in range(len(N1)):          #Aplica la probabilidad de muerte únicamente a los individuos infectados
            if A[N1[j][0],N1[j][1]]==1:
                N2.append(N1[j])
        ai=math.ceil(len(N2)*ranges_dead[i][2])-1
        vecN.append(N2); a.append(ai)
    for i in range(len(a)):
        for j in range(a[i]):
            b=random.randint(0,len(vecN[i])-1)
            v.append(vecN[i][b])
    for i in range(len(v)):
        B[v[i][0]][v[i][1]]=0
        C[v[i][0]][v[i][1]]=3
    return [C,B]

def evolution_sis_dd(alpha,beta,br,mr,ranges_dead,A,E,time_unit,year):   #Regla de evolución para el modelo SIS con muerte por enfermedad
    n,m=A.shape
    B=np.zeros((n,m))
    C=evolution_sis_bm(alpha,beta,br,mr,A,E,time_unit,year)   #Aplica el modelo con natalidad y mortalidad
    for i in range(n):
        for j in range(m):
            B[i,j]=C[0][i,j]
    D=dead_by_disease(ranges_dead,B,C[1])   #Se aplica la regla de muerte por enfermedad
    return D

def evolution_sir_dd(alpha,beta,br,mr,ranges_dead,A,E,time_unit,year):   #Regla de evolución para el modelo SIR con muerte por enfermedad
    n,m=A.shape
    B=np.zeros((n,m))
    C=evolution_sir_bm(alpha,beta,br,mr,A,E,time_unit,year)   #Aplica el modelo con natalidad y mortalidad
    for i in range(n):
        for j in range(m):
            B[i,j]=C[0][i,j]
    D=dead_by_disease(ranges_dead,B,C[1])   #Se aplica la regla de muerte por enfermedad
    return D

def evolution_SIS_dd(alpha,beta,tf,br,mr,ranges_dead,A,E,year):   #Aplica el modelo SIS con muerte por enfermedad tf veces sobre el sistema A
    L = [A]
    Ed = [E]
    i = 0                                 
    while i <= tf:                        
        i = i + 1 
        B=evolution_sis_dd(alpha,beta,br,mr,ranges_dead,L[i-1],Ed[i-1],i,year)
        L.append(B[0])
        Ed.append(B[1])
    return L

def evolution_SIR_dd(alpha,beta,tf,br,mr,ranges_dead,A,E,year):   #Aplica el modelo SIR con muerte por enfermedad tf veces sobre el sistema A
    L = [A]
    Ed = [E]
    i = 0                                 
    while i <= tf:                        
        i = i + 1 
        B=evolution_sir_dd(alpha,beta,br,mr,ranges_dead,L[i-1],Ed[i-1],i,year)
        L.append(B[0])
        Ed.append(B[1])
    return L

def SIS_dd_model(alpha,beta,tf,br,mr,ranges_dead,A,E,year):   #Modelo SIS con muerte por enfermedad
    S=[]; I=[]; D=[]           
    CI=np.zeros((tf,2))           
    CS=np.zeros((tf,2)) 
    CD=np.zeros((tf,2))
    B=evolution_SIS_dd(alpha,beta,tf,br,mr,ranges_dead,A,E,year)     
    for j in range(tf):          
        M=B[j]                     
        S.append(count_s(M))      
        I.append(count_i(M))  
        D.append(count_d(M))
    for i in range(tf):           
        CS[i][0]=i; CS[i][1]=S[i]   
        CI[i][0]=i; CI[i][1]=I[i]
        CD[i][0]=i; CD[i][1]=D[i]   
    return [CS,CI,CD,S,I,D,B]

def SIR_dd_model(alpha,beta,tf,br,mr,ranges_dead,A,E,year):   #Modelo SIR con muerte por enfermedad    
    S=[]; I=[]; R=[]; D=[]           
    CI=np.zeros((tf,2))           
    CS=np.zeros((tf,2))           
    CR=np.zeros((tf,2)) 
    CD=np.zeros((tf,2))
    B=evolution_SIR_dd(alpha,beta,tf,br,mr,ranges_dead,A,E,year)
    for j in range(tf):          
        M=B[j]                     
        S.append(count_s(M))      
        I.append(count_i(M))   
        R.append(count_r(M))  
        D.append(count_d(M))
    for i in range(tf):           
        CS[i][0]=i; CS[i][1]=S[i]   
        CI[i][0]=i; CI[i][1]=I[i]   
        CR[i][0]=i; CR[i][1]=R[i]
        CD[i][0]=i; CD[i][1]=D[i]   
    return [CS,CR,CI,CD,S,I,R,D,B]

def graph_sis_dd(alpha,beta,tf,br,mr,ranges_dead,A,E,year):   #Gráfica del modelo SIS con muerte por enfermedad
    SIS=SIS_dd_model(alpha,beta,tf,br,mr,ranges_dead,A,E,year)      
    three_states_graph_2(SIS[0],SIS[1],SIS[2], "Modelo SIS con muerte por enfermedad")

def graph_sir_dd(alpha,beta,tf,br,mr,ranges_dead,A,E,year):   #Gráfica del modelo SIR con muerte por enfermedad
    SIR=SIR_dd_model(alpha,beta,tf,br,mr,ranges_dead,A,E,year)      
    four_states_graph(SIR[0],SIR[2],SIR[1],SIR[3], "Modelo SIR con muerte por enfermedad")

def medium_curves_sis_dd(alpha,beta,tf,csim,I0,br,mr,ranges_dead,A,E,year):                  #Promedio de csim simulaciones para el modelo SIS con muerte por enfermedad
    S=[]; I=[]; D=[]                                                        #S, I y D guardarán el promedio de las cantidades normalizadas por estados respectivos
    cs=[]; ci=[]; cd=[]                                                     #cs, ci y cd serán las listas que permiten promediar la cantidad de individuos para csim simulaciones
    CI=np.zeros((tf,2)); CS=np.zeros((tf,2)); CD=np.zeros((tf,2))           #Hay tf coordenadas
    for i in range(csim):                                                   #Para csim simulaciones 
        promsis=SIS_dd_model(alpha,beta,tf,br,mr,ranges_dead,initial_condition(I0,A),E,year) #Aplique un condición inicial de distribución uniforme de infectados 
        cs.append(promsis[3]); ci.append(promsis[4]); cd.append(promsis[4]) #Las listas S, I y D generadas por cada iteración son enviadas a las listas cs, ci y cd
    for i in range(tf):                                                     #Se promedian las cantidades
        k=0; l=0; m=0
        for j in range(csim):
            k=k+cs[j][i]/csim; l=l+ci[j][i]/csim; m=m+cd[j][i]/csim  
        S.append(k); I.append(l); D.append(m)       #Las cantidades promedio son enviadas a las listas S, I y D
    for i in range(tf):                             #Se crean las listas de coordenadas
        CS[i][0]=i; CS[i][1]=S[i]
        CI[i][0]=i; CI[i][1]=I[i]
        CD[i][0]=i; CD[i][1]=D[i]
    return [CS,CI,CD,S,I,D]                         #Datos promedio del modelo SIS con muerte por enfermedad para csim simulaciones

def graph_medium_curves_sis_dd(alpha,beta,tf,csim,I0,br,mr,ranges_dead,A,E,year):   #Grafica del promedio de simulaciones para el modelo SIS con muerte por enfermedad
    SIS=medium_curves_sis_dd(alpha,beta,tf,csim,I0,br,mr,ranges_dead,A,E,year)
    three_states_graph_2(SIS[0],SIS[1],SIS[2],"Curva promedio - Modelo SIS_dd")

def medium_curves_sir_dd(alpha,beta,tf,csim,I0,br,mr,ranges_dead,A,E,year):                  #Promedio de csim simulaciones para el modelo SIR con muerte por enfermedad
    S=[]; I=[]; R=[]; D=[]                                                             #S,I, R y D guardarán el promedio de las cantidades normalizadas por estados respectivos
    cs=[]; ci=[]; cr=[]; cd=[]                                                         #cs,ci,cr y cd serán las listas que permiten promediar la cantidad de individuos para csim simulaciones
    CI=np.zeros((tf,2)); CS=np.zeros((tf,2)); CR=np.zeros((tf,2)); CD=np.zeros((tf,2)) #Hay tf coordenadas
    for i in range(csim):                                                              #Para csim simulaciones
        promsir=SIR_dd_model(alpha,beta,tf,br,mr,ranges_dead,initial_condition(I0,A),E,year) #Aplique un condición inicial de distribución uniforme de infectados 
        cs.append(promsir[4]); ci.append(promsir[5]); cr.append(promsir[6]); cd.append(promsir[7]) #Las listas S, I, R y D generadas por cada iteración son enviadas a las listas cs, ci, cr y cd
    for i in range(tf):                                                                            #Se promedian las cantidades
        k=0; l=0; p=0; m=0
        for j in range(csim):
            k=k+cs[j][i]; l=l+ci[j][i]; p=p+cr[j][i]; m=m+cd[j][i]
        k=k/csim; l=l/csim; p=p/csim;  m=m/csim 
        S.append(k); I.append(l); R.append(p); D.append(m)         #Las cantidades promedio son enviadas a las listas S, I, R y D
    for i in range(tf):                                            #Se crean las listas de coordenadas
        CS[i][0]=i; CS[i][1]=S[i]
        CI[i][0]=i; CI[i][1]=I[i]
        CR[i][0]=i; CR[i][1]=R[i]
        CD[i][0]=i; CD[i][1]=D[i]
    return [CS,CR,CI,CD,S,I,R,D]                                        #Datos promedio del modelo SIR para csim simulaciones

def graph_medium_curves_sir_dd(alpha,beta,tf,csim,I0,br,mr,ranges_dead,A,E,year):   #Grafica del promedio de simulaciones para el modelo SIR con muerte por enfermedad
    SIR=medium_curves_sir_dd(alpha,beta,tf,csim,I0,br,mr,ranges_dead,A,E,year)
    four_states_graph(SIR[0],SIR[2],SIR[1],SIR[3],"Curva promedio - Modelo SIR_dd")

def state_coor(A, state_value):         #Enlista los agentes que tengan un estado identificado con state_value
    n,m=A.shape
    v=[]
    for i in range(n):
        for j in range(m):
            if A[i,j] == state_value:  
                v.append([i,j])
    return v

def superposicion(A,B):   #Permiete visualizar dos sistemas sobre un mismo dominio 
    n,m=A.shape
    C=-np.ones((n,m))
    for i in range(n):
        for j in range(m):
            C[i,j]=A[i,j]
            if C[i,j]==-1:
                C[i,j]=B[i,j]
    return C

def transport(output,arrival,ages,list_prob):     #Todos los agentes tendrán una probabilidad de moverse, de acuerdo con el estado que posea
    n,m=output.shape
    A=output; B=arrival; E=ages
    A1=np.zeros((n,m)); B1=np.zeros((n,m)); E1=-np.ones((n,m))
    V1=[]
    for i in range(n):        #Se realiza para evitar ṕroblemas de apuntadores
        for j in range(m):
            A1[i,j]=A[i,j]
            B1[i,j]=B[i,j]
            E1[i,j]=E[i,j]
    for i in range(list_prob[0][0],list_prob[len(list_prob)-1][0]+1):
        V1.append(state_coor(A,i))
    for i in range(len(V1)):
        V2=state_coor(B1,75)
        for j in range(len(V1[i])):
            p=random.randint(0,100)
            if p <= list_prob[i][1]*100:
                k=random.randint(0,len(V1[i])-1)
                l=random.randint(0,len(V2)-1)
                A1[V1[i][k][0]][V1[i][k][1]]=B[V2[l][0]][V2[l][1]]
                B1[V2[l][0]][V2[l][1]]=A[V1[i][k][0]][V1[i][k][1]]
                E1[V1[i][k][0]][V1[i][k][1]]=E[V2[l][0]][V2[l][1]]
                E1[V2[l][0]][V2[l][1]]=E[V1[i][k][0]][V1[i][k][1]]
                V1[i].pop(k); V2.pop(l)
    return [A1,B1,E1]

def evolution_sis_wm(alpha,beta,list_prob,br,mr,ranges_dead,A,B,E,time_unit,year):    #Regla de evolución para el modelo SIS con movimiento de agentes
    C=transport(A,B,E,list_prob)
    C=transport(C[1],C[0],C[2],list_prob)
    K=C[2]
    D=evolution_sis_dd(alpha,beta,br,mr,ranges_dead,C[0],K,time_unit,year)
    E=evolution_sis_dd(alpha,beta,br,mr,ranges_dead,C[1],K,time_unit,year)
    n,m=A.shape
    for i in range(n):
        for j in range(m):
            if C[0][i,j]==75:
                D[0][i,j]=75
            if C[1][i,j]==75:
                E[0][i,j]=75
            if C[2][i,j]==0:
                D[0][i,j]=3
                E[0][i,j]=3
    K=superposicion(D[1],E[1])
    for i in range(n):
        for j in range(m):
            if D[0][i][j]==3 or E[0][i][j]==3:
                K[i][j]=0
    return [D[0],E[0],K]

def evolution_sir_wm(alpha,beta,list_prob,br,mr,ranges_dead,A,B,E,time_unit,year):   #Regla de evolución para el modelo SIR con movimiento de agentes
    C=transport(A,B,E,list_prob)
    C=transport(C[1],C[0],C[2],list_prob)
    K=C[2]
    D=evolution_sir_dd(alpha,beta,br,mr,ranges_dead,C[0],K,time_unit,year)
    E=evolution_sir_dd(alpha,beta,br,mr,ranges_dead,C[1],K,time_unit,year)
    n,m=A.shape
    for i in range(n):
        for j in range(m):
            if C[0][i,j]==75:
                D[0][i,j]=75
            if C[1][i,j]==75:
                E[0][i,j]=75
            if C[2][i,j]==0:
                D[0][i,j]=3
                E[0][i,j]=3
    K=superposicion(D[1],E[1])
    for i in range(n):
        for j in range(m):
            if D[0][i][j]==3 or E[0][i][j]==3:
                K[i][j]=0
    return [D[0],E[0],K]

def evolution_SIS_wm(alpha,beta,tf,list_prob,br,mr,ranges_dead,A,B,E,year):   #Aplica el modelo SIS con movimiento tf veces sobre los sitemas A y B
    L1=[A]; L2=[B]; L3=[E]
    for i in range(1,tf):
        M=evolution_sis_wm(alpha,beta,list_prob,br,mr,ranges_dead,L1[i-1],L2[i-1],L3[i-1],i,year)
        L1.append(M[0])
        L2.append(M[1])
        L3.append(M[2])
    return [L1,L2,L3]

def evolution_SIR_wm(alpha,beta,tf,list_prob,br,mr,ranges_dead,A,B,E,year):   #Aplica el modelo SIR con movimiento tf veces sobre los sitemas A y B
    L1=[A]; L2=[B]; L3=[E]
    for i in range(1,tf):
        M=evolution_sir_wm(alpha,beta,list_prob,br,mr,ranges_dead,L1[i-1],L2[i-1],L3[i-1],i,year)
        L1.append(M[0])
        L2.append(M[1])
        L3.append(M[2])
    return [L1,L2,L3]

def SIS_wm_model(alpha,beta,tf,list_prob,br,mr,ranges_dead,A,B,E,year):   #Modelo SIS con movimiento
    S=[]; I=[]; D=[]           
    CI=np.zeros((tf,2))           
    CS=np.zeros((tf,2))           
    CD=np.zeros((tf,2))
    C=evolution_SIS_wm(alpha,beta,tf,list_prob,br,mr,ranges_dead,A,B,E,year)
    for i in range(tf):
        M=superposicion(C[0][i],C[1][i])
        S.append(count_s(M))      
        I.append(count_i(M))   
        D.append(count_d(M))
    for i in range(tf):           
        CS[i][0]=i; CS[i][1]=S[i]   
        CI[i][0]=i; CI[i][1]=I[i]   
        CD[i][0]=i; CD[i][1]=D[i]   
    return [CS,CI,CD,S,I,D,C]

def SIR_wm_model(alpha,beta,tf,list_prob,br,mr,ranges_dead,A,B,E,year):   #Modelo SIR con movimiento
    S=[]; I=[]; R=[]; D=[]           
    CI=np.zeros((tf,2))           
    CS=np.zeros((tf,2))           
    CR=np.zeros((tf,2)) 
    CD=np.zeros((tf,2))
    C=evolution_SIR_wm(alpha,beta,tf,list_prob,br,mr,ranges_dead,A,B,E,year)
    for i in range(tf):
        M=superposicion(C[0][i],C[1][i])
        S.append(count_s(M))      
        I.append(count_i(M))   
        R.append(count_r(M))  
        D.append(count_d(M))
    for i in range(tf):           
        CS[i][0]=i; CS[i][1]=S[i]   
        CI[i][0]=i; CI[i][1]=I[i]   
        CR[i][0]=i; CR[i][1]=R[i]
        CD[i][0]=i; CD[i][1]=D[i]   
    return [CS,CR,CI,CD,S,I,R,D,C]

def graph_sis_wm(alpha,beta,tf,list_prob,br,mr,ranges_dead,A,B,E,year):   #Gráfica del modelo SIS con movimiento
    SIS=SIS_wm_model(alpha,beta,tf,list_prob,br,mr,ranges_dead,A,B,E,year)
    three_states_graph_2(SIS[0],SIS[1],SIS[2], "Modelo SIS con movimiento")

def graph_sir_wm(alpha,beta,tf,list_prob,br,mr,ranges_dead,A,B,E,year):   #Gráfica del modelo SIR con movimiento
    SIR=SIR_wm_model(alpha,beta,tf,list_prob,br,mr,ranges_dead,A,B,E,year)
    four_states_graph(SIR[0],SIR[2],SIR[1],SIR[3], "Modelo SIR con movimiento")